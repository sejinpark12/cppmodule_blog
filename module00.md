# C++ Module 00

## 네임스페이스(namespace)
### 식별자 충돌
**[식별자](https://docs.microsoft.com/ko-kr/cpp/cpp/identifiers-cpp?view=msvc-160)** (**identifier**)는 변수명, 클래스, 구조체, 열거형, 함수, 클래스 맴버 함수, `typedef`명 등을 정의의 할때 사용된다.
식별자 작성 규칙 상 같은 범위에서 **식별자가 중복되면 안된다.**
`some`이라는 이름으로 변수를 선언했다면 다른 변수뿐만 아니라 함수나 타입의 이름으로도 같은 이름을 사용할 수 없다.

프로그램의 규모가 커지고 여러명이 작업을 할 경우 식별자 충돌이 일어날 가능성이 크다. 그렇기 때문에 언어 차원에서 좀 더 근본적으로 해결할 수 있는 방법이 필요해졌고 이것이 **네임스페이스**가 필요해진 이유이다.

네임스페이스는 식별자들이 기억되는 영역이며 식별자의 소속 공간이다. 각 공간 영역을 만들고 이 영역 안에 식별자를 그룹화하여 넣어 두면 식별자 충돌 가능성이 대폭 감소된다.
소속 네임스페이스가 다르다면 식별자가 중복되어도 문제없다. 네임스페이스를 정의하는 기본 형식은 다음과 같다.

```cpp
namespace 네임스페이스 이름
{
    변수나 함수 선언
}
```

네임스페이스 이름도 식별자의 일종이므로 식별자 작성 규칙에 맞게 만들어야 한다. 

네임스페이스에 속한 식별자를 참조할 때는 `::`연산자 앞에 네임스페이스의 이름을 붙여 소속을 밝혀야 한다. `A::i`는 네임스페이스A에 소속된 `i`를 의미한다.
네임스페이스를 별도로 정의하지 않아도 항상 존재하는 네임스페이스가 있는데 이를 **전역 네임스페이스**라고 한다. 원래부터 존재하므로 별도의 네임스페이스 이름은 없다.

```cpp
int i;          // 전역 네임스페이스 소속
namespace A
{
    int i;      // A 소속
}

void func(void)
{
    int i;
    
    i = 1;      // 지역변수 i
    ::i = 2;    // 전역 네임스페이스 i
    A::i = 3;   // A 네임스페이스 i
}

int main(void)
{
    func();
    return (0);
}
```

---

### 네임스페이스 작성 규칙
1. 네임스페이스의 이름도 일종의 식별자이므로 다른 식별자와 중복되어서는 안된다.
2. 네임스페이스는 반드시 **전역 영역에 선언**해야 한다.
3. 네임스페이스 안에 또다른 네임스페이스를 선언할 수 있다.
```cpp
namesapce Game
{
    namespace Graphic
    {
        struct Screen{};
    }
    namespace Sound
    {
        struct Sori {};
    }
}
```
4. 네임스페이스를 여러번 나누어 선언할 수 있다.
```cpp
namespace A
{
    double i;
}
namespace A
{
    char name[32];
}
```
5. 네임스페이스가 이름을 가지지 않을 수도 있다.
```cpp
namespace
{
    int internal;
}
```
6. 네임스페이스 안에 함수를 정의할 때 헤더 파일에 원형만 선언하고 구현 파일에 함수의 본체를 작성한다. 

---

### 네임스페이스 사용
네임스페이스 안에 선언된 식별자를 사용하려면 매번 소속 네임스페이스를 밝히고 참조해야 하므로 매우 번거롭다.

```cpp
int main(void)
{
    MYNS::value = 3;
    MYNS::score = 1.2345;
    MYNS::func();
    return (0);
}
```

이런 불편함을 해결할 수 있는 세 가지 방법이 제공된다.

1. using 지시자(directive)

  전역 영역에 using 지시자가 있고 MYNS를 이 영역에서 사용하겠다고 지시했다. 이후 전역 영역에서 MYNS에 속한 식별자는 `MYNS::` 없이 바로 사용할 수 있다.
  using 지시자가 영향을 미치는 범위는 이 지시자가 있는 영역에 국한된다.

```cpp
#include <iostream>

namespace MYNS
{
    int value;
    double score;
    void func(void)
    {
        std::cout << "I am func" << std::endl;
    }
}

using namespace MYNS;

int main(void)
{
    value = 3;
    score = 1.2345;
    func();
    return (0);
}

```

2. using 선언(declaration)
  using 지시자는 지정한 네임스페이스의 모든 식별자를 가져오지만 using 선언은 하나의 식별자만 가져온다.
  using 선언이 있는 블록에 대해서만 영향을 미친다.

```cpp
#include <iostream>

namespace MYNS
{
    int value;
    double score;
    void func(void)
    {
        std::cout << "I am func" << std::endl;
    }
}

int main(void)
{
    using MYNS::value;

    value = 3;
    MYNS::score = 1.2345;
    MYNS::func();
    return (0);
}

void subfunc(void)
{
    MYNS::value = 3;
}
```

3. 별명
네임스페이스는 충돌을 방지하기 위해 긴 이름을 주는데 이름이 너무 길면 번거롭고 코드가 지저분해진다. 이럴 경우 `namespace A = VeryVeryLongNameSpaceName;`와 같이 짧은 별명을 정의할 수 있다.

```cpp
name space VeryVeryLongNameSpaceName
{
    struct Person {};
}

int main(void)
{
    namespace A = VeryVeryLongNameSpaceName;
    A::Person P;
}
```

---

## 클래스(class)
### 클래스의 탄생
C++의 구조체는 **멤버 함수를 포함할 수 있다**는 면에서 C의 구조체보다 의미가 확장되었다. 이형 타입 변수의 집합인 구조체가 스스로의 동작을 정의할 수 있다는 것은 객체 지향 구현 측면에서 매우 중요한 의미가 있다.

C의 전통적인 구조체와 C++에서 확장된 구조체의 차이를 구분하기 위해 확장된 의미의 구조체에 **클래스**라는 새로운 이름 붙혔다.

구조체 선언문에서 `struct` 키워드를 `class`라는 키워드로 바꾸기만 하면 클래스가 된다. C의 구조체와 다르게 C++의 구조체는 멤버 함수, 생성자, 파괴자를 가질 수 있고 상속도 가능하며 클래스가 쓰이는 모든 곳에 사용할 수 있다. C++에서 구조체와 클래스의 유일한 차이점은 멤버에 대한 **디폴트 접근 지정뿐이다.**

```cpp
struct S
{
    int x;      // 구조체의 디폴트접근지정은 public
}
S s;
s.x = 1234;     // 구조체 외부에서 접근 가능.

class C
{
    int x;      // 클래스의 디폴트접근지정은 private
}
C c;
c.x = 1234;     // 클래스 외부에서 접근 불가능.
```

구조체의 디폴트 접근 지정은 `public`이고 클래스의 디폴트 접근 지정은 `private`이다. 클래스는 객체의 안정성을 위해 외부에서 멤버 데이터를 함부로 접근하지 못하게 멤버를 숨기는 것을 지향한다. 하지만 C++의 구조체는 C언어와의 호환성을 위해 디폴트 접근 지정이 `public`일 수 밖에 없다.

---

### 클래스의 선언

```cpp
class ClassName
{
public:
    멤버 변수;
    멤버 함수;
private:
    멤버 변수;
    멤버 함수;
};              // 세미콜론 반드시 필요하다.
```

구조체와 마찬가지로 멤버 개수에 제한이 없다. `int`, `long`, `double` 등의 기본 자료형은 물론이고 배열, 구조체 등의 유도형과 다른 클래스형의 변수까지 멤버로 포함할 수 있다.
구조체와 동일하게 중첩이 가능하다.

---

### 클래스는 타입이다.
C++에서는 **구조체의 태그가 타입으로 승격**되어 태그만으로 구조체 변수를 선언할 수 있다. [C와 C++ 구조체의 차이](https://saack.tistory.com/75)
마찬가지로 C++에서 클래스는 `int`, `double`, `char`와 같은 기본형 타입과 동일한 하나의 **타입으로 취급**된다. 클래스가 완전한 타입으로 취급될 수 있도록 C++은 여러가지 언어적 장치(생성자, 연산자 오버로딩 등)를 제공한다.

|정수형|클래스|C++의 관련 문법|
|--|--|--|
|`int i;`|`Complex C;`|클래스의 이름이 타입과 같은 자격을 가진다.|
|`int i = 3;`|`Complex C(1.0, 2.0);`|**생성자**를 사용하여 선언과 동시에 초기화 할 수 있다.|
|`int i = j;`|`Complex D = C;`|**복사 생성자**를 사용하여 같은 타입의 다른 객체로부터 생성된다.|
|`i = j;`|`D = C;`|대입 연산자|
|`i + j;`|`D + C;`|연산자 오버로딩|
|`i = 3.14;`|`Complex C(1.2);`|변환 생성자, 변환 함수|
|`3 + i;`|`1.0 + C;`|전역 연산자 함수와 프렌드|

C++이 클래스를 완전한 타입으로 취급하므로 클래스로부터 **유도형 타입**(기본형 타입으로 부터 만들어지는 타입. 예: 배열, 구조체, 공용체, 포인터, 함수형 포인터)을 만들 수 있다. 그러므로 클래스의 배열이나 클래스형 변수를 가리키는 포인터도 만들 수 있다.

---

### 인스턴스
클래스는 타입일 뿐 그 자체가 정보를 저장하는 변수는 아니다. **클래스를 선언한다고 해서 실제로 값을 기억할 수 있는 메모리가 할당되지 않는다.** 클래스형의 변수를 선언해야 실제 메모리가 할당된다.

```cpp
Position Here;
Complex C;
```

클래스 변수 선언문에 의해 생성된 변수를 **인스턴스**(Instance)라고 한다. 인스턴스는 클래스가 **메모리에 구현된 실체**이며 우리가 지금까지 변수라고 불러왔던 개념과 동일하다.
프로그래밍 대상은 클래스가 아니라 인스턴스이고 한 클래스에 대해 여러 개의 인스턴스를 동시에 생성할 수 있다.

```cpp
Position A, B, C;
```

위 선언에 의해 `Position` 형의 인스턴스 A, B, C가 메모리에 각각 생성된다. `int i, j, k;` 선언에 의해 세 개의 정수형 변수가 동시에 생성되는 것과 같다.

개별 인스턴스가 독립적인 정보를 저장할 수 있어야 하기 때문에 각 인스턴스들은 클래스에 선언된 **멤버 변수를 각각 따로 가진다.** 그런 이유 인스턴스의 실제 크기는 클래스에 선언된 **모든 멤버 변수의 총 크기와 같다.**

인스턴스의 상태(멤버 변수)는 달라질 수 있지만 동작(멤버 함수)은 모두 동일하기 때문에 **멤버 함수는 클래스에 속한 모든 인스턴스들이 공유한다.**

인스턴스의 다른 표현은 **오브젝트**(Object)이다.

|영어|번역|의미|
|--|--|--|
|인스턴스(Instance)|실체|메모리에 구현되어있다.|
|오브젝트(Object)|객체|독립성을 가진 부품이다.|

## member functions

## stdio stream

## initialization lists

## static

## const

## 출처
